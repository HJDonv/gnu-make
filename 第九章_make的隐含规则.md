# 第九章 使用隐含规则

尽管我们不能改变 make 内嵌的隐含规则，但是我们可以使用模式规则重新定义自己的隐含规则。

## 9.1 隐含规则的使用

使用 make 内嵌的隐含规则，我们的 Makefile 中就不需要明确给出重建某一个目标的命令，甚至可以不用写出明确的规则。

make 会自动根据已存在（或者可以被创建）的源文件类型来启动相应的隐含规则。这里说的“可被创建”的文件是指：**这个文件在 Makefile 中被作为目标或者依赖明确的提及，或者可以根据已存在的文件使用其它的隐含规则来创建**。

通常， **make会对那些没有命令行的规则、 双冒号规则寻找一个隐含规则来执行**。作为一个规则的依赖文件，在没有一个规则明确描述它的依赖关系的情况下； make会将其作为一个目标并为它搜索一个隐含规则，试图重建它。**注意：当规则没有命令行的时候，给目标文件指定明确的依赖文件并不会影响隐含规则的搜索。**

我们来看一个例子：

	foo.o: foo.p

这个规则指定了“foo”的依赖文件是“foo.p”。但是如果在工作目录下存在同名.c源文件“foo.c”。
执行make的结果就不是用“pc”编译“foo.p”来生成“foo”，而是用“cc”编译“foo.c”来生
成目标文件。这是因为在隐含规则列表中对.c文件的隐含规则处于.p文件隐含规则之前。当需要给目标指定明确的重建规则时，规则描述中就不能省略命令行，这个规则必须提供明确的重建命令来说明目标需要重建所需要的动作。

为了能够在存在“foo.c”的情况下编译“foo.p”。
规则可以这样写：

	foo.o: foo.p
	pc $< -o $@

另外：**当我们不想让make为一个没有命令行的规则中的目标搜索隐含规则时，我们需要使用空命令来实现**。

## 9.5 模式规则

模式规则类似于普通规则，只是在模式规则中，目标的定义中需要包含“%”字符（确切地说
是一个），包含“%”的目标被用来匹配一个文件名，“%”可以匹配任何非空字符串。规则的依赖
文件中同样可以使用“%”，依赖中的“%”的取值情况由目标中的“%”来决定。我们可以使用模式规则来定义一个隐含规则。

> 也就是说“普通规则”和“模式规则”是处于一个同等级的概念。


需要注意的是：“%”的替换是在规则的其他变量和函数引用扩展完成之后进行的，变量和函
数的展开一般发生在make读取Makefile时，而模式规则中的“%”则发生在make的执行过程。（没看懂什么意思）

一个模式规则的格式为：

	%.o : %.c ; COMMAND...

这个模式规则指定了如何由文件“N.c”来创建文件“N.o”，文件“N.c”应该是已存在的或者可被创建的。

模式规则中依赖文件也可以不包含模式字符“%”。当模式规则的依赖文件名中不包含模式字符“%”时，它的含义是所有符合目标模式的目标文件都依赖于一个指定的文件。

### 9.5.1 模式规则介绍

1. 模式规则在Makefile中的顺序需要注意，当一个目标文件符合多个模式规则的目标时，make将会按照第一个找到的作为重建它的规则。
2. 在Makefile中指定的模式规则会覆盖隐含的模式规则。就是说在Makefile中明确指定的会替代隐含的模式规则。
3. 另外，依赖文件存在或者被提及的规则，优先于那些需要使用隐含规则来创建其依赖文件的规则

### 9.5.4 模式的匹配

通常，模式规则中目标模式由前缀、后缀、模式字符“%”组成，这三个部分中可以同时两部分为空。实际的文件名应该是以模式指定的前缀开始、后缀结束的任何文件名。

### 9.5.5 万用规则

当一个模式规则的目标为“%”（它可以匹配任何文件名）时，我们称这个规则为万用规则。

### 9.5.6 重建内嵌隐含规则

对隐含规则，我们可以对它进行重建。重建一个隐含规则时，需要使用相同的目标和依赖文件，但是命令可以不同。这样就替代了有相同目标和依赖的那个make内嵌的规则，替代之后的隐含规则的顺序由它在Makefile中的位置决定。例如通常我们Makefile中可能会包含这样一个规则：

	%.o : %.c
	$(CC) $(CFLAGS) –D__DEBUG__ $< -o $@

这个模式规则替代了编译.c文件的内嵌隐含规则。

也可以取消一个内嵌的隐含规则。

	%.o : %.s