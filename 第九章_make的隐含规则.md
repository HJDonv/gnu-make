# 第九章 使用隐含规则

尽管我们不能改变 make 内嵌的隐含规则，但是我们可以使用模式规则重新定义自己的隐含规则。

## 9.1 隐含规则的使用

使用 make 内嵌的隐含规则，我们的 Makefile 中就不需要明确给出重建某一个目标的命令，甚至可以不用写出明确的规则。

make 会自动根据已存在（或者可以被创建）的源文件类型来启动相应的隐含规则。这里说的“可被创建”的文件是指：**这个文件在 Makefile 中被作为目标或者依赖明确的提及，或者可以根据已存在的文件使用其它的隐含规则来创建**。

通常， **make会对那些没有命令行的规则、 双冒号规则寻找一个隐含规则来执行**。作为一个规则的依赖文件，在没有一个规则明确描述它的依赖关系的情况下； make会将其作为一个目标并为它搜索一个隐含规则，试图重建它。**注意：当规则没有命令行的时候，给目标文件指定明确的依赖文件并不会影响隐含规则的搜索。**

我们来看一个例子：

	foo.o: foo.p

这个规则指定了“foo”的依赖文件是“foo.p”。但是如果在工作目录下存在同名.c源文件“foo.c”。
执行make的结果就不是用“pc”编译“foo.p”来生成“foo”，而是用“cc”编译“foo.c”来生
成目标文件。这是因为在隐含规则列表中对.c文件的隐含规则处于.p文件隐含规则之前。当需要给目标指定明确的重建规则时，规则描述中就不能省略命令行，这个规则必须提供明确的重建命令来说明目标需要重建所需要的动作。

为了能够在存在“foo.c”的情况下编译“foo.p”。
规则可以这样写：

	foo.o: foo.p
	pc $< -o $@

另外：**当我们不想让make为一个没有命令行的规则中的目标搜索隐含规则时，我们需要使用空命令来实现**。

## 9.5 模式规则

模式规则类似于普通规则，只是在模式规则中，目标的定义中需要包含“%”字符（确切地说
是一个），包含“%”的目标被用来匹配一个文件名，“%”可以匹配任何非空字符串。规则的依赖
文件中同样可以使用“%”，依赖中的“%”的取值情况由目标中的“%”来决定。我们可以使用模式规则来定义一个隐含规则。

> 也就是说“普通规则”和“模式规则”是处于一个同等级的概念。


需要注意的是：“%”的替换是在规则的其他变量和函数引用扩展完成之后进行的，变量和函
数的展开一般发生在make读取Makefile时，而模式规则中的“%”则发生在make的执行过程。（没看懂什么意思）

一个模式规则的格式为：

	%.o : %.c ; COMMAND...

这个模式规则指定了如何由文件“N.c”来创建文件“N.o”，文件“N.c”应该是已存在的或者可被创建的。

模式规则中依赖文件也可以不包含模式字符“%”。当模式规则的依赖文件名中不包含模式字符“%”时，它的含义是所有符合目标模式的目标文件都依赖于一个指定的文件。

### 9.5.1 模式规则介绍

1. 模式规则在Makefile中的顺序需要注意，当一个目标文件符合多个模式规则的目标时，make将会按照第一个找到的作为重建它的规则。
2. 在Makefile中指定的模式规则会覆盖隐含的模式规则。就是说在Makefile中明确指定的会替代隐含的模式规则。
3. 另外，依赖文件存在或者被提及的规则，优先于那些需要使用隐含规则来创建其依赖文件的规则

### 9.5.4 模式的匹配

通常，模式规则中目标模式由前缀、后缀、模式字符“%”组成，这三个部分中可以同时两部分为空。实际的文件名应该是以模式指定的前缀开始、后缀结束的任何文件名。

### 9.5.5 万用规则

当一个模式规则的目标为“%”（它可以匹配任何文件名）时，我们称这个规则为万用规则。

### 9.5.6 重建内嵌隐含规则

对隐含规则，我们可以对它进行重建。重建一个隐含规则时，需要使用相同的目标和依赖文件，但是命令可以不同。这样就替代了有相同目标和依赖的那个make内嵌的规则，替代之后的隐含规则的顺序由它在Makefile中的位置决定。例如通常我们Makefile中可能会包含这样一个规则：

	%.o : %.c
	$(CC) $(CFLAGS) –D__DEBUG__ $< -o $@

这个模式规则替代了编译.c文件的内嵌隐含规则。

也可以取消一个内嵌的隐含规则。

	%.o : %.s

## 9.6 缺省规则

	%::
		touch $@
对没有找到的所有的.c文件使用“touch”命令创建一个空的文件。

实现一个缺省规则的方式也可以不使用万用规则来实现， 可以使用伪目标“.DEFAULT”。上边的例子也可以这样来书写：

	.DEFAULT :
		touch $@
对于没有命令行的伪目标“.DEFAULT”，其含义是取消前边所有使用“.DEFAULT”指定的缺省执行命令。

## 9.8 隐含规则搜索算法

对于目标“T”， make为它搜索隐含规则的算法如下。此算法适合于： 

1. 任何没有命令行的双冒号规则； 
2. 任何没有命令行的普通规则； 
3. 那些不是任何规则的目标、但它是另外某些规则的依赖文件； 
4. 在递归搜索过程中，隐含规则链中前一个规则的依赖文件。

搜索过程如下：

1. 将目标“T”的目录部分分离，分离后目录部分称为“D”，其它部分称“N”。例如：“T”
为“src/foo.o”时， D就是“src/”，“N”就为“foo.o”。
2. 列出所有和“T”或者“N”匹配的模式规则。如果模式规则的目标中包含斜杠，则认为和
“T”相匹配，否则认为此模式规则和“N”相匹配。
3. 只要这个模式规则列表中包含一个非万用规则的规则，那么将列表中所有的非最终万用规则删除。如果不将万用规则标志为最终规则，那么它就是非最终规则。一个非最终万用规则不能用于特殊类型的文件。只有其它规则（非万用规则）的目标才能匹配特殊类型的文件名。 
例如，文件名‘foo.c' 和格式规则 `%.c : %.y' (该规则运行Yacc)的目标匹配。无论该规则是否实际使用(如果碰巧存在文件‘foo.y’，该规则将运行)，和目标匹配的事实就能足够阻止任何非最终万用规则在文件foo.c上使用。这样，make 考虑就不试图从文件‘foo.c.o',‘foo.c.c', ‘foo.c.p'等创建可执行的‘foo.c'。
4. 删除这个模式规则列表中的所有没有命令行的规则。
5. 对于这个模式规则列表中的所有规则：
a) 计算出模式规则的“茎” S， S应该是“T”或“N”中匹配“%”的非空的部分。
b) 计算依赖文件。把依赖中的“%”用“S”替换。如果目标模式中不包含斜杠，则
把“D”加在替换之后的每一个依赖文件开头，构成完整的依赖文件名。
c) 测试规则的所有依赖文件是否存在或是应该存在（一个文件，如果在Makefile中它
作为一个明确规则的目标，或者依赖文件被提及，我们就说这个文件是一个“应该
存在”的文件）。如果所有的依赖文件都存在、应该存在或是这个规则没有依赖。退出查找，使用该规则。 
6. 截止到第5步，合适的规则还是没有被找到，进一步搜索。对于这个模式规则列表中的每一规则：
a) 如果规则是一个终止规则，则忽略它，继续下一条模式规则。
b) 计算依赖文件（同第5步）。
c) 测试此规则的依赖文件是否存在或是应该存在。
d) 对于此规则中不存在的依赖文件，递归的调用这个算法查找它是否可由隐含规则来创建。
e) 如果所有的依赖文件存在、应该存在、或是它可以由一个隐含规则来创建。退出查找，使用该规则。
7. 如果没有隐含规则可以创建这个规则的依赖文件，则执行特殊目标“.DEFAULT”所指定
的命令（可以创建这个文件，或者给出一个错误提示）。如果在Makefile中没有定义特殊目
标“DEFAULT”，就没有可用的命令来完成“T”的创建。 make退出。
一旦为一类目标查找到合适的模式规则。除匹配“T”或者“N”的模式以外，对其它模式规则
中的目标模式进行配置，使用“茎” S替换其中的模式字符“%”，将得到的文件名保存直到执行命
令更新这个目标文件（“T”）。在命令执行以后，把每一个储存的文件名放入数据库，并且标志为已
更新，其时间戳和文件“T”相同。

在执行更新文件“T”的命令时，使用自动化变量表示规则中的依赖文件和目标文件。



本章节部分内容摘抄：http://blog.chinaunix.net/xmlrpc.php?r=blog/article&uid=22238267&id=5747980，侵权删。