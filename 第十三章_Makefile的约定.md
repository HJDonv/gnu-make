# 第十三章 Makefile的约定

## 13.1 基本的约定

为了最大可能的兼容不同版本的 make，这里给出了一些基本的约定。

1、所有的 Makefile 中应该包含这样一行：SHELL = /bin/sh
这样做的目的是为了避免变量“SHELL”在有些系统上可能继承同名的系统环境变量而导
致错误。虽然在 GNU 版本的 make 中不会出现这种问题（ GNU make 中变量“SHELL”
的默认值是“/bin/sh”，它不同于系统环境变量“SHELL”）。

2、小心处理后缀和隐含规则。Makefile 中应该这样做：

	.SUFFIXES:
	.SUFFIXES: .c .o
第一行首先取消掉 make 默认的可识别后缀列表，第二行通过特殊目标“.SUFFIXES”重
新指定可识别的。

3、小心处理规则中的路径。当需要处理指定目录的的文件时，需要明确指定路径。如“./”
代表当前目录，“$(srcdir)”代表源代码目录。当没有指定明确路径时，意味着是当前目
录。我们可以通过“configure”脚本的选项“--srcdir”指定源代码所在的目录（可参
考 GNU 发布的软件包中的 configure 脚本）。

4、使用GNU make的变量“VPATH”指定搜索目录。当规则只有一个依赖文件时。我们应该使用自动化变量 “$<”和“$@”代替出现在命令的依赖文件和目标文件（其它版本的make，
只在隐含规则中设置自动化变量“$<”）。这些文件在发布时就在源代码的目录中。因此 Makefile 中对它们的重建也应该是在源代码目录，而不应该在 build 目录。相反的，对于那些本来就不存在于源代码目录下的文件，也不应该将它们创建在源代码的目录下。 要记住， make 的过程不应该以任何方式修改源代码，或者改变源代码目录的结构。

##13.2 规则命令行的约定

1、书写 Makefile 时，规则的命令（包括其他的脚本文件，如： configure）应该是“sh”而不应该是“csh”所支持的。

2、用于创建和安装的“configure”脚本和 Makefile 中的命令除下面所列出的意外，避免使用其它命令：
cat cmp cp diff echo egrep expr false grep install-info
ln ls mkdir mv pwd rm rmdir sed sleep sort tar test touch true

3、在目标“dist”的命令行中可以使用压缩工具“gzip”。

6、重建或者安装目标（一般是伪目标）的命令行可使用编译器或者相关工具程序， 应该使用一个变量来表示所要执行的命令。这样会比较方便，需要修改一个命令时，只需要更改变量的值就可以了。对于以下的这些命令程序：

	ar bison cc flex install ld ldconfig lex
	make makeinfo ranlib texi2dvi yacc
在 Makefile 规则中的命令行中，使用以下这些变量来代替它们：

	$(AR) $(BISON) $(CC) $(FLEX) $(INSTALL) $(LD) $(LDCONFIG) $(LEX)
	$(MAKE) $(MAKEINFO) $(RANLIB) $(TEXI2DVI) $(YACC)
对另外一些命令组件的使用，应该都是通过变量的形式来实现。例如如下的这些命令：

	chgrp chmod chown mknod

我们可以在 Makefile 中为这些命令组件定义一个代表它的变量（如： CHRP、 CHMOD 等，在命令行中就可以使用$(CHMOD)来引用）。

## 13.3 代表命令变量

Makefile 应该为重设所有的命令、选项等提供变量。就是说用户可以通过修改一个变量值来重新指定所要执行的命令，或者来控制命令执行的选项、参数等。

Makefile 中，所有的命令都应该使用变量定义。在规则中需要使用此命令时，通过对相应的变量的引用来实现命令的调用。例如：定义变量“CC = gcc”，规则中可用“$(CC)”来引用“gcc”。

对于一些件管理器工具如“ln”，“rm”“mv”等，可以不为它们定义变量，而直接使用。

为所有命令执行的选项参数也应该定义一个变量（可称为命令的选项变量）。在命令变量（代
表一个命令的变量）后添加“FLAGS”来命名这个选项变量。例如：变量“CFLAGS”是 c 编译器
（命令变量为“CC”）的命令行选项变量。变量“LDFLAGS”是命令“ld”（命令变量为“LD”）的选项变量等。规则中 c 预处理的命令使用变量“CCFLAGS”来替代；同样任何需要执行链接的命令行中使用“LDFLAGS”作为命令行选项。

c编译器的编译选项变量“CFLAGS”在Makefile中通常是为编译所有的源文件提供选项的变量。

如果需要使用 make 实现文件的安装，则在 Makefile 中需要定义变量“INSTALL”。此变量代表安装命令 （install ）。 同时在 Makefile 中需要定义变量“INSTALL\_PROGRAM ” 和“INSTALL\_DATA ”（ “INSTALL\_PROGRAM ” 的 缺 省 值 都 是 “$(INSTALL) ”；
“INSTALL\_DATA”的缺省值是“${INSTALL} –m 644”）。可以是用这些变量，来安装可执行程序或者非可执行程序到指定位置。例如：

	$(INSTALL_PROGRAM) foo $(bindir)/foo
	$(INSTALL_DATA) libfoo.a $(libdir)/libfoo.a

## 13.4 安装目录变量

### 以下所罗列的两个变量是指定安装文件的根目录。所有其它安装目录都使它们的子目录。文件
不能直接安装在这两个目录下。

	prefix

这个前缀用于构造下列（除这两个安装根目录以外的其它目录变量）变量的缺省值。变量
“prefix”缺省值是“/usr/local”。

	exec_prefix

这个前缀用于构造下列变量的缺省值。变量“exec\_prefix”缺省值是“$(prefix)”。通常，“$(exec\_prefix)”目录中的子目录中存放和机器相关文件（例如可执行文件和例程库）。“$(prefix)”目录的子目录存放通用的一般文件。

### 文件（包括可执行程序、说明文档等）的安装目录：

	bindir
用于安装一般用户可运行的可执行程序。通常它的值为：“/usr/local/bin”，使用时应写为：
“$(exec_prefix)/bin”。

	sbindir
安装可在shell中直接调用执行的程序。这些命令仅对系统管理员有用（系统管理工具）。通
常它的值为：“/usr/local/sbin”，要求在使用时应写为：“$(exec_prefix)/sbin”。

	libexecdir
用于安装那些通常不是由用户直接使用，而是由其它程序调用的可执行程序。通常它的值为：
“/usr/local/libexec ”， 要 求 在 使 用 时 应 写 为 ： “$(exec_prefix)/libexec ”。 

### 程序执行时使用的数据文件可从以下两个方面来分类：

1、是否可由程序更改。程序可更改或者不能更改的文件（虽然用户可编辑其中某些文件）。

2、是否和体系结构相关。和体系结构无关的文件，可被所有类型的机器共享；体系相关文件，仅可被相同类型机器、操作系统共享；其它的就是那些不能被任何两个机器共享的
文件。

在 Makefile 中应该使用以下变量为不同类型的文件指定对应的安装目录：

	datadir
用于安装和机器体系结构无关的只读数据文件。通常它的值为：“/usr/local/share”，使用
时应写为： “$(prefix)/share”。

	sysconfdir
用于安装从属于特定机器的只读数据文件，包括：主机配置文件、邮件服务、网络配置文件、
“/etc/passwd”文件等。所有该目录下的文件都应该是普通文本文件（可识别的“ASCII”
码文本文件）。通常它的值为：“/usr/local/etc”，在使用时应写为：“$(prefix)/etc”。
不要将可执行文件安装在这个目录下（可执行文件的安装目录应该是“$(libexecdir)”或
者“$(sbindir)”）。也不要在这个目录下安装那些需要更改的文件（系统的配置文件等）。
这些文件应该安装在目录“$(localstatedir)”下。

	sharedstatedir
用于安装那些可由程序运行时修改的文件，这些文件与体系结构无关。通常它的值为：
“/usr/local/com”，要求在使用时应写为：“$(prefix)/com”。

	localstatedir
用于安装那些可由程序运行时修改的文件，但这些文件和体系结构相关。用户没有必要通过
直接修改这些文件来配置软件包，对于不同的配置文件，将它们放在“$(datadir)”或者
“$(sysconfdir)”目录中。“$(localstatedir)”值通常为：“/usr/local/var”，在使用时
应写为：“$(prefix)/var”。

	libdir
用于存放编译后的目标文件（ .o）文件库文件（文档文件或者执行的共享库文件）。不要在此目录下安装可执行文件（可执行文件应该安装在目录“$(libexecdir)”下）。变量libdir值常为：“/usr/local/lib”，使用时应写为：“$(exec_prefix)/lib”。

	infodir
用于安装软件包的 Info 文件。它的缺省值为： “/usr/local/info”，使用时应写为：
“$(prefix)/info”。

	lispdir
用于安装软件包的Emacs Lisp文件的目录。它的缺省值为：“ /usr/local/share/emacs/site-lisp ” ，使用时应写为：“$(prefix)/share/emacs/site-lisp”。

	includedir
用于安装用户程序源代码使用 “#include ” 包含的头文件。它的缺省值为：“/usr/local/include”，使用时应写为：“$(prefix)/include”。

除GCC外的大多数编译器不会在目录“/usr/local/include”中搜寻头文件，因此这种方式
只适用GCC编译器。这一点应该不是一个问题，因为很多情况下一些库需要GCC才能工作。
对那些依靠其它编译器的库文件，需要将头文件安装在两个地方，一个由变量“includedir”
指定，另一个由变量“oldincludedir”指定。

	oldincludedir
它所指定的目录也同样用于安装头文件，这些头文件用于非GCC的编译器。它的缺省值为：
“/usr/include”。Makefile在安装头文件时，需要判断变量“oldincludedir”的值是否为空。如果是空值，
就不使用它进行头文件的安装（一般是安装完成“/usr/local/include”下的头文件之后才
安装此目录下的头文件）。

一个软件包的安装不能替换该目录下已经存在的头文件，除非是同一个软件包（重新使用相
同的软件包在此目录下安装头文件）。例如，软件包“Foo”需要在“oldincludedir”指定
的目录下安装一个头文件“foo.h”时，可安装的条件为： 1. 目录“$(oldincludedir)”目
录下不存在头文件“foo.h”； 2. 已经存在头文件“foo.h”，存在的头文件“foo.h”是之
前软件包“Foo”安装的。

### Unix 风格的帮助文件需要安装在以下目录中：

	mandir	它的缺省值为：“/usr/local/man”，要求在使用时应写为： “$(prefix)/man ”。
	man1dir	它的缺省值为：“$(mandir)/man1”。
	man2dir	它的缺省值为：“$(mandir)/man2”。
	manext
	man1ext
	man2ext

### 而且下列这些变量也应该在 Makefile 中定义：

	srcdir
此变量指定的目录是需要编译的源文件所在的目录。该变量的值在使用“configure”脚本对
软件包进行配置时产生的。

例如：

	\# 安装的普通目录路径前缀。
	\# 注意：该目录在开始安装前必须存在
		prefix = /usr/local
		exec_prefix = $(prefix)
	\# 放置“gcc”命令使用的可执行程序
		bindir = $(exec_prefix)/bin
	\# 编译器需要的目录
		libexecdir = $(exec_prefix)/libexec
	\# 软件包的 Info 文件所在目录
		infodir = $(prefix)/info
在用户标准指定的目录下安装大量文件时，可以将这些文件分类安装在指定目录的多个子目录下。可以在 Makefile 中实现一个“install”伪目标来描述安装这些文件的命令（包括创建子目录，安装文件到对应的子目录中）。

在发布的软件包中，不能强制要求用户必须指定这些安装目录的变量。使用一套标准的安装目录变量来指定安装目录，当用户需要指定安装目录时，通过修改变量定义来指定具体的目录，在用户没有指定的情况下，使用默认的目录。

## 13.5 Makefile的标准目标名

	all
此目标的动作是编译整个软件包。“all”应该为Makefile的终极目标。该目标的动作不重建
任何文档文件（只编译所有的源代码，生成可执行程序）； 缺省情况下，对所有源程序的编译和连接应该使用选项“-g”，是最终的可执行程序中包含调试信息。当最终的可执行程序不需要包含调试信息时，可用“strip”去掉可执行程序中的调试符号已缩减最终的程序大小。

	install
此目标的动作是完成程序的编译并将最终的可执行程序、库文件等拷贝到安装的目录。如果只是验证这些程序是否可被正确安装，它的动作应该是一个测试安装动作。

尽可能保证目标“install”的动作不更改程序创建目录（ builid目录）下的任何文件，对这个目录下文件的修改（重建或者更新）是目标“all”所要定义的动作。

“install”目标定义的动作在安装目录不存在时，能够创建这些不存在的安装目录。这些目录包括：变量“prefix”和“exec_prefix”指定的目录和所有必要的子目录。完成此任务的方式可以使用下边介绍的“installdirs”目标。

	uninstall
删除所有已安装文件——由install创建的文件拷贝。规则所定义的命令不能修改编译目录下
的文件，仅仅是删除安装目录下的文件。

	install-strip
和目标install的动作类似，但是install-strip指定的命令在安装时对可执行文件进行strip
（去掉程序内部的调试信息）。

	clean
清除当前目录下编译生成的所有文件，这些文件由make程序创建。记住，不要删除软件包
的配置文件，同时需要保留build时创建的那些文件（诸如：创建的目录、 build生成的信息
记录文件等）。因为这些文件都是发布版本的一部分。

## 13.6 安装命令分类

在为 Makefile 书写“install”目标时，需要将其命令分为三类：正常命令、安装前命令和安
装后命令。

正常命令是把文件移动到合适的地方，并设置它们的模式。这个过程不修改任何文件，仅仅是把需要安装的文件从软件包中拷贝到安装目录。安装前命令和安装后命令可能修改某些文件；通常，修改一些配置文件和系统的数据库文件。典型地，安装前命令在正常命令之前执行，安装后命令在正常命令执行后执行。大多数情况是，安装后命令是运行“install-info”程序。它所完成的工作不能由正常命令完成，因为它更新了一个文件（ Info 的目录），该文件不能单独的或者完整的从软件包来进行安装，因为它只能在正常安装命令完成安装软件包的 info 文档之后才可正确执行。大多数程序不需要安装前命令，但应该在 Makefile 中提供。