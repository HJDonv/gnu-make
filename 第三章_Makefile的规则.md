# 第三章 Makefile的规则
## 3.2 规则语法

规则的中心思想：**目标文件的内容是由依赖文件文件决定，依赖文件的任何一处改动，将导致目前已经存在的目标文件的内容过期**

- Makefile 中对“$”有特殊的含义（表示变量或者函数的引用），如果我们的规则需要“$”，需要书写两个连续的（“$$”）

## 3.4 文件名使用通配符

Makefile 中通配符可以出现在以下两种场合：

1. 可以用在规则的目标、依赖中，此时 make 会自动将其展开；
2. 可出现在规则的命令中，其展开是在 shell 在执行此命令时完成；
3. 需要借助函数 “wildcard”。（这种情况一般用在变量定义）

> 之所以要使用wildcard的原因：

>如果 Makefile 有这样一句：“objects = \*.o”。那么变量“objects”的值就是“\*.o”，而不是使用空格分开的所有.o 文件列表。当objects作为依赖文件时候，如果没有任何.o文件，那么在执行规则时将会得到一个类似于“没有创建\*.o 文件的规则” 的错误提示，这当然不是我们所期望的结果，我们期望的是它能够按照.c文件生成对应的.o文件。


> 原理/解决方法：

>在规则中，通配符会被自动展开。但在变量的定义和使用函数时，通配符不会被自动的展开。这种情况下需要通配符有效，要用到函数“wildcard”，
如果需要变量“objects”代表所有的.o 文件，则需要是用函数“wildcard”来实现（ objects = $(wildcar \*.o)）

除了上述三种情况，其场合都不可以直接使用通配符。

## 3.5 目录搜索（针对依赖文件目录搜索）

一般搜索 & 选择性搜索：

1. 一般搜索：使用VPATH变量
2. 选择性搜索：使用vpath关键字

## 3.10、3.11 多规则目标、多目标规则

一般用于描述目标文件和依赖文件之间的关系。


## 3.12 静态模式

静态模式规则是这样一个规则：规则存在多个目标，并且不同的目标可以根据目标文件的名字
来自动构造出依赖文件。

## 3.13 双冒号规则

双冒号规则就是使用“::”代替普通规则的“:”得到的规则。当同一个文件作为多个规则的目标时，双冒号规则的处理和普通规则的处理过程完全不同（双冒号规则允许在多个规则中为同一个目标指定不同的重建目标的命令）。

## 3.14 自动产生依赖

目的：Makefile 中，可能需要书写一些规则来描述一个.o 目标文件和头文件的依赖关系。

1）我们可以使用如下的模式规则来自动生成每一个.c 文件对应的.d 文件：

	%.d: %.c
		$(CC) -M $(CPPFLAGS) $< > $@.$$$$; \
		sed 's,\($*\)\.o[ :]*,\1.o $@ : ,g' < $@.$$$$ > $@; \
		rm -f $@.$$$$
此规则的含义是：所有的.d 文件依赖于同名的.c 文件。

2）在书中这一章节其中提到了将编译器产生的依赖关系：
 
	main.o : main.c defs.h
	转成：
	main.o main.d : main.c defs.h
为什么要将main.d加入目标文件列表？

其实是为了得到最新的.o文件的依赖关系，主要体现在修改.h文件的时候。


假设不把main.d加入目标文件列表，从1）可知，由于%.d的依赖只有%.c，如果现在defs.h里面新增include "test.h"，也就是修改.h文件，那么再次执行make的时候，main.d是不会更新的（make在解析makefile时候发现main.d的依赖main.c没有更新（参考%.d:%.c规则），所以也就不需要更新main.d文件），这就导致了main.d文件里面的main.o目标没有最新的依赖，即 main.o ： main.c defs.h test.h。

如果把main.d加入目标文件列表，在defs.h里面新增include "test.h"，那么再次执行make的时候，main.d是会更新的（main.d文件中的目标main.d的依赖defs.h被修改了，导致了需要重建目标main.d），这样main.d中的规则：

	main.o main.d:main.c defs.h
	就会转成：
	main.o main.d:main.c defs.h test.h